#!/usr/bin/env node
const path = require("path");
const fs = require("fs");
const { spawnSync } = require("child_process");
const os = require("os");
const sources = [];

const interpreters = {
  zsh: "zsh",
  sh: "sh",
  bash: "bash",
  js: "node",
  javascript: "node",
  py: "python",
  python: "python"
};

const extensions = {
  zsh: "zsh",
  sh: "sh",
  bash: "bash",
  node: "mjs",
  python: "py"
};

function findMarkdownFiles(folder) {
  const results = [];
  const files = fs.readdirSync(folder);

  for (const file of files) {
    const filePath = path.join(folder, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      results.push(...findMarkdownFiles(filePath));
    } else if (stat.isFile() && path.extname(file).toLowerCase() === ".md") {
      results.push(filePath);
    }
  }

  return results;
}

let dir = process.cwd();

for (;;) {
  const file = path.join(dir, "x.md");
  if (fs.existsSync(file) && fs.statSync(file).isFile()) {
    sources.push(file);
  }
  const folder = path.join(dir, "x");
  if (fs.existsSync(folder) && fs.statSync(folder).isDirectory()) {
    sources.push(...findMarkdownFiles(folder));
  }
  if (dir === "/") break;
  dir = path.dirname(dir);
}

const commands = sources
  .map((source) => {
    const content = fs.readFileSync(source, "utf8");
    return content.trim();
  })
  .join("\n\n\n")
  .split(/^## /gm)
  .slice(1)
  .map((block) => {
    const body = block.slice(block.indexOf("\n") + 1).trim();
    const info = body.split("```")[0].trim();
    const code = body.split("```")[1].trim();
    return {
      name: block.split("\n")[0].trim(),
      info,
      type: code.split("\n")[0].trim(),
      code: code.split("\n").slice(1).join("\n")
    };
  });

if (process.argv[2] === "__list_commands") {
  commands.forEach((c) => console.log(c.name));
  process.exit(0);
}

if (process.argv[2] === "--zsh-completion") {
  console.log(`\
# BEGIN XFile completions

function _x_completion {
  local -a options
  options=(\${(f)"$(x __list_commands 2>/dev/null)"})
  _describe "choices" options
}

compdef _x_completion x

# END XFile completions
`);
  process.exit(0);
}

for (const command of commands) {
  if (command.name === process.argv[2]) {
    if (process.argv[3] === "--help") {
      console.log(command.info);
      process.exit(0);
    }

    if (interpreters[command.type]) {
      const p = path.join(
        ".",
        `.x-${Date.now()}-${Math.random()}.${
          extensions[interpreters[command.type]]
        }`
      );

      function cleanup() {
        if (fs.existsSync(p)) {
          try {
            fs.unlinkSync(p);
          } catch (error) {
            console.error(`Error removing temporary file ${p}:`, error.message);
          }
        }
      }

      try {
        fs.writeFileSync(p, command.code);
        const result = spawnSync(
          interpreters[command.type],
          [p, ...process.argv.slice(3)],
          {
            stdio: "inherit",
            encoding: "utf-8"
          }
        );
        cleanup();
        process.exit(result.status);
      } catch (error) {
        console.error(
          `x: error executing ${command.type} command:`,
          error.message
        );
        cleanup();
        process.exit(1);
      }
    } else {
      console.error("x: unsupported interpreter", command.type);
    }
    process.exit(0);
  }
}

if (!process.argv[2]) {
  console.error("x: no command provided");
  process.exit(1);
}

console.error(`x: command not found: ${process.argv[2]}`);
process.exit(1);
